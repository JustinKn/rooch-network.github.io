# 为 Layer1 状态扩容

区块链要承载大规模的用户，除了要解决交易执行的吞吐量难题，同时还有一个业界尚未普遍关注的难题就是状态扩容。显而易见，如果亿级用户在链上持有很多各种类型的资产以及应用的状态，状态爆炸问题迟早要面对。

这个问题在 Token 时代还不明显，毕竟 Token 是可以拆分合并，且只需要用一个数字来表达。到了 NFT 爆发的时代，这个问题就很明显了，大量的 NFT 发行者希望将 NFT 的元数据乃至图片都保存在链上。等下一步 Web3 应用爆发，各种应用创造出来的新型资产或者应用状态，如果都想保存在链上，就必须解决状态爆炸的问题。

当前 Layer1 上解决状态爆炸的主要思路是实现状态计费，通过成本逼迫用户谨慎使用链上状态，激励用户删除无用的状态。但这个方法并不能从根本上解决状态爆炸问题，只能延缓这个问题。

Rooch 利用 Move 的状态特性，设计出一种跨层的状态迁移方案，可以将状态从 Layer1 迁移到 Layer2，从而实现给 Layer1 状态扩容。

## 状态迁移的方案

状态迁移的整体思路是在链上维护一个链上更新，链下存储的表结构（mapping 或 table），我们可以称为 `RollupMap`。

RollupMap 在链上合约中只保存根节点，全量数据保存在链下，在 Rooch 中就是保存在 Layer2 验证节点上。

当链上的状态迁移到 RollupMap 中后，验证节点会在链下应用执行状态树的操作，实现状态的迁移。
当链下状态需要迁移会链上时，需要携带状态树的节点证明，在链上执行操作。当然，同时还要考虑挑战周期的问题。

### RollupMap

:::note

这里需要一张图

:::


1. 首先 RollupMap 是一颗稀疏默克尔树（Sparse Merkle Tree，简称 SMT）。SMT 可以提供不存在证明，有了不存在证明，可以在没有全局状态的情况下，实现链上更新校验。
2. 我们将 RollupMap 的变更定义为 RM_OP，每个 RM_OP 会改变状态树的叶节点，从而会改变状态树的根，链上合约可以通过操作和证明计算出新的根节点，也就是说，根节点的更新是可合约验证的。
    ```
    non-inclusion proof + new key&value = inclusion proof => new root
    inclusion proof - old key&value = non-inclusion proof => new root
    ```
3. RollupMap 只支持两种 OP ：
   * `move_to` 将状态迁移到状态树中，该操作需要携带不存在证明，证明操作目标的叶子节点不存在。
   * `move_from` 将状态从状态树中移出，改操作需要携带存在证明，证明操作目标的叶子节点存在。
4. 通过以上方式，可以实现一个由智能合约保证安全的链下状态树，但它的操作需要都发生在链上。
5. 如果我们允许链下修改 RollupMap，就需要配合挑战机制，等挑战期过后，再将最终确定的状态树的根更新到 RollupMap。

由于 Move 和 EVM 的状态机制不一样，所以这套方案在两种不同链上使用方式也不一样。

### Move 链的状态迁移

:::note

这里也需要一张图

:::

由于 Move 本身提供了“自由状态”能力，让状态可以跨合约移动，所以可以由 Rooch Framework 提供合约实现状态的跨合约移动，应用只需要将状态转移给 Rooch Framework 里的 RollupMap。

当然，还需要同时提供可以通过状态证明创建和销毁状态对象的能力。

### EVM 链的状态迁移

EVM 中的状态不能跨合约移动，但每个合约内部可以维护一个 RollupMap，在内部实现状态迁移。等状态映射到 Layer2 后，可以通过 Move 变为“自由状态”。

:::note

这里还需要一张图

:::

但这个方式只适合新的合约，如何支持已经部署的合约，需要进一步研究。

:::note

TODO 通过 Solidity 代码来表达 

:::

### 相关链接

* [RollupMap](https://github.com/movefuns/movefuns/issues/10)



