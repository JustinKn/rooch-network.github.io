# Rooch - Towards Web3 Native DApps

There are already more than a dozen of great Web3 infrastructures who are constantly breaking the boundary of blockchain technology and trying to take our industry a step further toward the dream of Web3.

In this brief article you will find our vision regarding Web3 and why do we want to build Rooch.

## Web3 Native DApp

The adjective "Web3 Native" comes from the term "[Cloud Native](https://www.oracle.com/cloud/cloud-native/what-is-cloud-native/)". It refers to the DApps that takes full advantage of decentralization provided by the blockchain technology, which makes it a 100% Web3 DApplication.

Below are the architecture of the most current Web3 App (Hybrid Web3 App) and the one of the DApp that we envision (Web3 Native DApp).

import Image from "next/image";

<Image
  src="/docs/web3-native-dapp.png"
  alt="Hello"
  width={450}
  height={450}
  class="mx-auto my-8"
/>

A Hybrif Web3 App usually adopts the same architecture of a Web2 App where the user send requests from the frontend to the backend server and the server does the computation and storage. The only different it makes is that, in the backend server, there is a private key which operates tokens on a decentralized blockchain "on behalf of" the users.

To compare with, A Web3 Native DApp does not have a centralized private key controlling users' assets. The backend of the DApp is fully implemented in a smart contract runtime, where the logics defined by the contracts controls everything from the users' assets to the functionality of the DApp.

## Breakdown with 6 Questions

Here's a table that shows the differences these two types of Web3 architecture will bring to the end users.

### Does user own their data and state?

### Can governance make actual changes?

### Are the assets secured by trust or verification?

### Is it censorship resistant?

### How's the performance and user experience?

## Applications

Rooch offers 2 unique application design patterns for applications that provides a huge design space for application builders
Resource-Oriented Programming, enabled by Move Language
Every pieces of data published by users are owned by themselves as assets, and all the assets have limitless composability
(e.g. Games can have trustless free market for players to trade in-game assets and fabricate unique new assets)
Every single functional module can be updated with governance
(e.g. Grow an application from a DAO, all the DAO members can collectively build up an App, solves the cold start issue for Web3 DApps)
(e.g. Players can design and launch their own adventure for other players to enjoy)
Language level safety can help with saving the security audit cost
(e.g. DeFi protocols launched on Move platform can leverage the native formal verification system to largely save the audit cost)
Object Model + Account Model (Originally Designed by Rooch)
(e.g. Store user assets as objects and store index in global storage)

Web3 Native DApp, enabled by the Modular Off-Chain architecture
As Layer2, Rooch is high performance and low cost
(e.g. Light applications such as Casino Games or Social Networks can be fully implemented with smart contracts so that they can be fully Asset-Oriented)
As Layer3, comparing to App-Chain solutions, In-Contract Storage is Roochâ€™s competitive advantage, which is a demand that is currently targetted by EthStorage;
Layer3 also provides an even better scalability
(e.g. Social Network apps and Games can store image and other data directly in the contract)
(e.g. Git3 can store the codes directly in contract so that it ensures a better governance mechanism)
As P2P State Channel, Rooch creates trust for P2P applications
(e.g. PVP Games can be hosted in a decentralized way with ensured fairness)
(e.g. Content Streaming platform can integrate streaming payment)
In conclusion, whatever Web3 DApps will find Rooch to be the most suitable solution.

## Why Rooch?

### Move Language

Here are the reasons why Rooch adopts Move as the smart contract language:

- **Resource Oriented Programming** - which is a new smart contract development paradigm introduced and enabled by Move Language, this enables a broader design space for Web3 application.
- **Safety** - The [type ability system of Move](https://move-book.com/advanced-topics/types-with-abilities.html) provides language level safety to the smart contract assets; in addition, Move Language has a native formal verification tool called [Move Prover](https://github.com/move-language/move/blob/main/language/move-prover/doc/user/prover-guide.md), which potentially could reduce the cost for smart contract security audits
- **Collectively Built by Communities** - As a new programming language, Move is promoted by more than just one communities and projects. (See [Awesome-Move](https://awesome-move.com/#move-powered-blockchains) for a list of Move powered blockchains)
- **Rich Crypto Native Features** - Move Language has built-in support for features such as contract upgradability and account abstraction.
- **More thesis on why Move**:
  - [Why Move? From the Perspective of Programming Language Ecosystem Building](/blog/why-move-ecosystem)
  - [Move vs Solidity](https://docs.sui.io/learn/why-move#move-vs-solidity)

### Modular Blockchain

## Conclusion

<Image
  src="/docs/web3-comparsion.png"
  alt="Hello"
  width={700}
  height={500}
  class="mx-auto my-4"
/>
